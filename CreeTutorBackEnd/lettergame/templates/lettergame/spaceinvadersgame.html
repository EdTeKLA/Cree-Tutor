<!doctype html>
{% load static %}
<html>
<head>

    <meta charset="utf-8">
    <title>Space Invader !!</title>
    <style>
        body {
            background-color: #0F4C15;
        }
    </style>

</head>
<script src="https://pixijs.download/release/pixi.min.js"></script>


<script src="{% static 'lettergame/js/pixi.min.js' %}"></script>




<body>

    <font size="6" color="white" face="Comic Sans MS">

        <p>space invaders and it kinda works now! >:^) </p>

    </font>

    <style>
        * {
            top: 50%;
            left: 50%;
        }
    </style>

    <script type="text/javascript">

                /*Space Invaders Game, JS code begins
                PIXI JS app used
                -creates stage 500x500 pixels on HTML webpage
                -creates graphic of grass along bottom of screen
                -creates 'shooter1' sprite on stage
                -enables 'shooter1' to move along stage horizontally and stay within boundaries
                -<link rel="shortcut icon" href="favicon.ico"/>
                */



        let app = new PIXI.Application({

             //create canvas description
            width: 500,
            height: 500,
            antialias: true,    // default: false
            transparent: false, // default: false
            resolution: 1,       // default: 1
        });

        //add canvas
        document.body.appendChild(app.view);
        app.renderer.backgroundColor = 0xC6E9F5;

        //Add images to
        PIXI.loader
            .add("{% static 'lettergame/image/shooter-1.png' %}")
            .add("{% static 'lettergame/image/bottomboundary.png' %}")
            .add("{% static 'lettergame/image/bullet.png' %}")
            .add("{% static 'lettergame/image/invader2.png' %}")
            .add("{% static 'lettergame/image/invadershot2.png' %}")
            
            //calls function 'setup'
            .load(setup)
            .load(boundaries);
       // let outerpBar = new PIXI.Graphics();
      // PIXI.
       
            //calls function 'boundaries'
           

            //functions of code start
            //initialize global variables of functions below
            let shooter1, state, bottomBoundary, bullet, invader, invaders, invadershot, shooter1hit, correctCheck;
            
            let bullets = [];
            let pow_array = [];
            let level = "{{level}}";
            let correctArr = [];
           

            function boundaries() {
                let bottomBoundaries = 17,
                spacing = 30,
                xOffset = 0;

                //array to store all bottom boundary blocks
                bottomBlocks = [];
                //for loop adds blocks until bottom row of stage is filled with grass
                for (let i = 0; i < bottomBoundaries; i++) {
                    //create sprite
                    let bottomBoundary = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/bottomboundary.png' %}"].texture);
                    let x = spacing * i + xOffset;
                    let y = 470;

                    bottomBoundary.x = x;
                    bottomBoundary.y = y;

                    bottomBlocks.push(bottomBoundary);
                    app.stage.addChild(bottomBoundary)
                }
            }
            function setup() {
                 //add sprite to stage at starting position
                shooter1 = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/shooter-1.png' %}"].texture);
                shooter1.x = 225;
                shooter1.y = 460;
                shooter1.vx = 0;
                shooter1.vy = 0;
                app.stage.addChild(shooter1);
               // let level = "{{level}}";
                let options = [];
                {% for letter in letters %}
                options.push("{{letter.name}}");
                //var text = new PIXI.Text("{{letter.name}}", { font: "30px Arial",outline-color: black fill: "red" });
                /*text.x = invader.x;
                text.y = invader.y + 10;*/
                //app.stage.addChild(text);
                
                {% endfor %}
                //let sound = ("{% static ''%}{{sound.sound}}");
                
                var audio = new Audio("{% static ''%}{{sound.sound}}");
                audio.play();
                let correct = new String("{{sound.name}}");
                
                //let correct = string.substring(34, 35);
                
                //create specifics of sprite 'bullet'

                bullet = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/bullet.png' %}"].texture);
                //Create the health bar                      //Create the points bar
                var style = new PIXI.TextStyle({                //var style = new PIXI.TextStyle({
                    fontFamily: 'Arial',
                    fontSize: 12,
                    fontStyle: 'italic',
                    fontWeight: 'bold',
                    fill: ['#000000'], // gradient
                    stroke: '#4a1850',
                    strokeThickness: 1,
                     
                }); 
                var health = new PIXI.Text('HEALTH : ', style);
                health.x = 10;
                health.y = 7;
                app.stage.addChild(health);

                healthBar = new PIXI.Container();          
                healthBar.x = 70;
                healthBar.y = 10;
                app.stage.addChild(healthBar);

                //Create the black background rectangle
                let innerhBar = new PIXI.Graphics();
             
                innerhBar.lineStyle(3, 0x000000, 1);
                innerhBar.beginFill(0x000000, 1);
                innerhBar.drawRoundedRect(0, 0, 90, 10, 7);
                innerhBar.endFill();
                healthBar.addChild(innerhBar);

                
                //Create the front red rectangle
                let outerhBar = new PIXI.Graphics();
               
                outerhBar.beginFill(0xFF3300, 1);
                outerhBar.drawRoundedRect(0, 0, 90, 10, 7);
                healthBar.addChild(outerhBar);

                healthBar.outer = outerhBar;


                //Create the points bar
                var style = new PIXI.TextStyle({
                    fontFamily: 'Arial',
                    fontSize: 12,
                    fontStyle: 'italic',
                    fontWeight: 'bold',
                    fill: ['#000000'], // gradient
                    stroke: '#4a1850',
                    strokeThickness: 1,

                });
                var points = new PIXI.Text('POINTS : ', style);
                points.x = 200;
                points.y = 7;
                app.stage.addChild(points);

                pointBar = new PIXI.Container();
                pointBar.x = 260;
                pointBar.y = 10;
                app.stage.addChild(pointBar);

                //Create the black background rectangle
                let innerpBar = new PIXI.Graphics();

                innerpBar.lineStyle(3, 0x000000, 1);
                innerpBar.beginFill(0x000000, 1);
                innerpBar.drawRoundedRect(0, 0, 90, 10, 7);
                innerpBar.endFill();
                pointBar.addChild(innerpBar);

                pointBar.inner = innerpBar;

                //Create the front red rectangle
                let outerpBar = new PIXI.Graphics();

                outerpBar.beginFill(0xF4A500, 1);
                outerpBar.drawRoundedRect(0, 0, 90, 10, 7);
                
                pointBar.addChild(outerpBar);

                pointBar.outer = outerpBar;
                pointBar.outer.width = 0;
                
                 
                
                //creare invader as a sprite and invadershot as sprite
                // invader = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/invader2.png' %}"].texture);
                invadershot = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/invadershot2.png' %}"].texture);

                let
                    numofInvaders = options.length;
                    //spacing = 30;
                    xOffset = 0;
                if (level === 'easy') {
                    speed = 3;
                    spacing = 70;
                    
                } else if (level === 'med') {
                    speed = 4;
                    spacing = 50;
               
                } else if (level === 'hard') {
                    speed = 5;
                    spacing = 30;
                   
                }
                direction = 1;

                invaders = [];
                
                for (let i = 0; i < numofInvaders; i++) {
                    invader = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/invader2.png' %}"].texture);

                    let x = spacing * i;
                    let y = 25 * i + 2;
                    invader.x = x;
                    invader.y = y;

                    invader.vx = speed * direction;
                    direction *= -1;
                    var style = new PIXI.TextStyle({
                        fontFamily: 'Arial',
                        fontSize: 20,
                        fontStyle: 'italic',
                        fontWeight: 'bold',
                        fill: ['#ffffff'], 
                        stroke: '#000000',
                        strokeThickness: 2,

                    });
                    // let randomValue = randomInt(0, numofInvaders);
                    var text = new PIXI.Text(options[i],style);
                    if (options[i] == correct) {
                        
                        correctCheck === i;
                        correctArr.push(invader);
                    } 
                    invader.addChild(text);
                    //put current invader inside invaders arraay
                    invaders.push(invader);
                    //add invader to stage 
                    app.stage.addChild(invader);
                }
               



                //Capture the keyboard arrow keys for use in moving 'shooter1'
                let left = keyboard(37),
                shoot = keyboard(32),
                right = keyboard(39),
                down = keyboard(40);
                upCount = 0;

                //Left arrow key `press` method
                //Change the shooter1's velocity when the key is pressed
                left.press = () => {
                shooter1.vx = -5;
                shooter1.vy = 0;
                };

                //Left arrow key `release` method
                left.release = () => {
                //If the left arrow has been released, and the right arrow isn't down,
                //and the shooter1 isn't moving vertically:
                //Stop the shooter1
                if (!right.isDown && shooter1.vy === 0) {
                shooter1.vx = 0;
                }
                };


                //Space bar shoot
                shoot.press = () => {


                    if (wait(500, bullet) === true) {
                         upCount++
                         let bulletNum = upCount;
                            bullet = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/bullet.png' %}"].texture);
                            bullets.push(bullet);
                            bullet.vy = -15;
                            bullet.y = 460;
                            bullet.x = (shooter1.x + 2);
                            app.stage.addChild(bullet);
                            bullet.time = new Date().getTime();
                    }
                };
                shoot.release = () => {
                    if (!down.isDown && shooter1.vx === 0) {
                        shooter1.vy = 0;

                    }
                };
                //Right
                right.press = () => {
                    shooter1.vx = 5;
                    shooter1.vy = 0;
                };
                right.release = () => {
                    if (!left.isDown && shooter1.vy === 0) {
                        shooter1.vx = 0;
                    }
                };
                //Down
                down.press = () => {
                    shooter1.vy = 0;
                    shooter1.vx = 0;
                };
                down.release = () => {
                    if (!shoot.isDown && shooter1.vx === 0) {
                        shooter1.vy = 0;
                    }
                };

                //Set the game state
                //call function 'play'
                state = play;

                //Start the game loop
                //call function 'gameLoop'
                app.ticker.add(delta => gameLoop(delta));
            }
            function keyboard(keyCode) {
                //function initializes keyboard keys as used to move sprites
                let key = {};
                key.code = keyCode;
                key.isDown = false;
                key.isUp = true;
                key.press = undefined;
                key.release = undefined;
                //The `downHandler`
                key.downHandler = event => {
                if (event.keyCode === key.code) {
                if (key.isUp && key.press) key.press();
                key.isDown = true;
                key.isUp = false;
                }
                event.preventDefault();
                };

                //The `upHandler`
                key.upHandler = event => {
                if (event.keyCode === key.code) {
                if (key.isDown && key.release) key.release();
                key.isDown = false;
                key.isUp = true;
                }
                event.preventDefault();
                };

                //Attach event listeners
                window.addEventListener("keydown", key.downHandler.bind(key), false);
                window.addEventListener("keyup", key.upHandler.bind(key), false);
                return key;
            }
            function gameLoop(delta) {
                //function will update the current game state:
                 state(delta);

            }
            function play(delta) {
                let shooter1Hit;
                let Contain = { x: 0, y: 0, width: 500, height: 500 };
                let shooter1hitsWall = contain(shooter1, Contain);

                if (shooter1hitsWall === "left" || shooter1hitsWall === "right") {
                    shooter1.vx = 0;
                }

                //Use the shooter1's velocity to make it move
                shooter1.x += shooter1.vx;
                shooter1.y += shooter1.vy;
                for (let i = 0; i < invaders.length; i++) {
                   
                    invaders[i].x += invaders[i].vx;
                    let invaderhitsWall = contain(invaders[i], { x: 0, y: 0, width: 500, height: 500 });
                    if (invaderhitsWall === "right" || invaderhitsWall === "left") {
                        invaders[i].vx *= -1;
                        invaders[i].y += 15;
                    }
                
                }
                let hitCheck;
                 gotHit = [];
                 hitInvader = [];
                for (let j = 0, k = invaders.length; j < k; j++) {
                    for (let i = 0; i < bullets.length; i++) {
                        let destroyInvader = hitTestRectangle(bullets[i], invaders[j]);
                        if (destroyInvader === true) {
                            hitCheck = true;
                            if (correctArr[0] === invaders[j]) {
                                console.log('correct');
                                hitCheck = true;
                            } else {
                                console.log('wrong')
                            }
                            app.stage.removeChild(invaders[j]);
                            app.stage.removeChild(bullets[i]);
                            gotHit.push(j);
                            hitInvader.push(i);
                            invaders[j].vx = 0;
                            bullets[i].vy = 0;
                            // invadershot = new PIXI.Sprite(PIXI.loader.resources["{% static 'lettergame/image/invadershot2.png' %}"].texture);
                            invadershot.x = invaders[j].x;
                            invadershot.y = invaders[j].y;
                            invadershot.time = new Date().getTime();
                            pow_array.push(invadershot)
                            app.stage.addChild(pow_array[pow_array.length - 1]);

                        } else {

                        }


                    }
           
                    if (hitTestRectangle(shooter1, invaders[j])) {
                        shooter1Hit = true;
                    }

                    if (shooter1Hit) {

                        //Make the explorer semi-transparent
                        shooter1.alpha = 0.5;

                        /*insert 3 if or else loops to create the level of health removed 
                         * depending on the level of difficulty you're playing on
                         */ 
                          
                         
                        //Reduce the width of the health bar's inner rectangle by 1 pixel
                        if (level === 'easy') {
                            //healthBar.outer.radius = 59;
                            //healthBar.outer.height = 4;
                            healthBar.outer.width -= 30;
                            
                        } else if (level === 'med') {;
                            healthBar.outer.width -= 23;
                        } else if (level === 'hard') {
                            healthBar.outer.width -= 18;
                        }

                        app.stage.removeChild(invaders[j]);
                        gotHit.push(j);
                        invaders[j].vx = 0;


                    } else {

                        //Make the explorer fully opaque (non-transparent) if it hasn't been hit
                        shooter1.alpha = 1; 
                    }
                }
                if (hitCheck) {
                    console.log('points should be higher');
                    
                    pointBar.outer.width += 30;
                   // pointBar.outer.radius = 7;
                    hitCheck = false;
                }
                goodbye_pow = [];
                for (let i = 0, l = pow_array.length; i < l; i += 1) {
                     if (wait(500, pow_array[i]) === true) {
                        app.stage.removeChild(pow_array[i]);
                        goodbye_pow.push(i)
                     }
                }
                 arraySplice(bullets, hitInvader);
                arraySplice(invaders, gotHit);
                arraySplice(pow_array, goodbye_pow);


                out_of_bounds = [];
                for (let i = 0; i < bullets.length; i += 1) {
                    let bullethitsWall = contain(bullets[i], Contain);
                    if (bullethitsWall === "top") {
                        app.stage.removeChild(bullets[i]);
                        out_of_bounds.push(i);
                    } else {
                      bullets[i].y += bullets[i].vy;
                    }
                }
            
                for (let j = 0, l = out_of_bounds.length; j < l; j += 1) {
                    bullets.splice(out_of_bounds[j], 1);

                }


            }
            function contain(sprite, Contain) {
                //function contains 'shooter1' to borders of the stage
                let collision = undefined;

                //Left
                if (sprite.x < Contain.x) {
                    sprite.x = Contain.x
                    collision = "left";
                }

                //Top
                if (sprite.y < Contain.y) {
                    sprite.y = Contain.y;
                    collision = "top";
                }

                //Right
                if (sprite.x + sprite.width > Contain.width) {
                    sprite.x = Contain.width - sprite.width;
                    collision = "right";
                }

                //Bottom
                if (sprite.y + sprite.height > Contain.height) {
                    sprite.y = Contain.height - sprite.height;
                    collision = "bottom";
                }

                //Return the `collision` value
                return collision;
            }
            function hitTestRectangle(r1, r2) {

                //Define the variables we'll need to calculate
                let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

                //hit will determine whether there's a collision
                hit = false;

                //Find the center points of each sprite
                r1.centerX = r1.x + r1.width / 2;
                r1.centerY = r1.y + r1.height / 2;
                r2.centerX = r2.x + r2.width / 2;
                r2.centerY = r2.y + r2.height / 2;

                //Find the half-widths and half-heights of each sprite
                r1.halfWidth = r1.width / 2;
                r1.halfHeight = r1.height / 2;
                r2.halfWidth = r2.width / 2;
                r2.halfHeight = r2.height / 2;

                //Calculate the distance vector between the sprites
                vx = r1.centerX - r2.centerX;
                vy = r1.centerY - r2.centerY;

                //Figure out the combined half-widths and half-heights
                combinedHalfWidths = r1.halfWidth + r2.halfWidth;
                combinedHalfHeights = r1.halfHeight + r2.halfHeight;

                //Check for a collision on the x axis
                if (Math.abs(vx) < combinedHalfWidths) {

                    //A collision might be occuring. Check for a collision on the y axis
                    if (Math.abs(vy) < combinedHalfHeights) {
                    //There's definitely a collision happening
                    hit = true;
                    } else {
                        //There's no collision on the y axis
                        hit = false;
                    }
                } else {
                     //There's no collision on the x axis
                    hit = false;
                }
    
                //`hit` will be either `true` or `false`
                return hit;
            }
            function wait(ms, object) {
                let start = object.time;
                let end = new Date().getTime();
                if (end < start + ms) {
                    end = new Date().getTime();
                } else {
                    return true
                }
            }
        function arraySplice(mainArray, notinUse) {
            //let mainArray, notinUse = [];
            for (let i = 0; i < notinUse.length; i++) {
                mainArray.splice(notinUse[i], 1);

            }
        }
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
            function end() {
                //end game make it a choice to play again 

            }

    </script>
</body>
</html>
